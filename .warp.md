# Kairos Designer - Full-Stack Project Configuration

## Project Overview
**Kairos Designer** is a unified full-stack application consisting of:
- **Frontend (kdes-fe)**: React 18 + Vite + JavaScript application
- **Backend (kdes)**: Python Flask + SQLAlchemy API server

Both applications work together as a single integrated project, with real-time communication via Socket.IO and a disciplined API architecture.

## Project Structure
```
E:\10 Documents\20 Projects\103_kairos_designer\
├── kdes-fe/          # Frontend: React + Vite
│   ├── src/
│   │   ├── api/      # ⚡ CRITICAL: Centralized API layer
│   │   ├── components/
│   │   ├── contexts/
│   │   ├── hooks/
│   │   ├── layouts/
│   │   ├── pages/
│   │   └── utils/
│   ├── public/
│   └── package.json
├── kdes/             # Backend: Python Flask
│   ├── kairos/
│   │   ├── blueprints/
│   │   ├── models/
│   │   ├── config/
│   │   ├── utils/
│   │   └── app.py
│   ├── run.py
│   └── requirements.txt
└── .warp.md         # This file
```

## 🚨 CRITICAL ARCHITECTURAL RULES

### API Architecture Discipline (MANDATORY)
**NEVER violate these rules when making API calls:**

1. **ALWAYS use ApiBroker via functional API modules**
2. **NEVER make direct fetch() calls to the backend**
3. **NEW APIs must be added to appropriate functional modules:**
   - `authApi.js` - Authentication, user management, OAuth
   - `functionalApi.js` - Core business logic, CRUD operations
   - `assistantApi.js` - AI assistant functionality
   - `contentApi.js` - Content management
   - `sysadminApi.js` - System administration

### ApiBroker Pattern (REQUIRED)
```javascript
// ✅ CORRECT: Always follow this pattern
import ApiBroker from "../api/apiBroker";
const apiBroker = new ApiBroker("/api"); // Use appropriate base path

export const newApiCall = async (params) => {
  return apiBroker.request("/endpoint", "METHOD", data);
};

// ❌ FORBIDDEN: Never do direct fetch calls
const badApiCall = async () => {
  const response = await fetch('https://kairos:5002/api/endpoint');
  return response.json();
};
```

### ApiBroker Features to Utilize:
- **Authentication**: JWT tokens automatically added to all requests
- **Error Handling**: Consistent error structure with status codes
- **File Downloads**: Use `apiBroker.downloadFile(uuid, filename)`
- **Blob Responses**: Use `responseType: "blob"` option for file previews
- **Server-Sent Events**: Use `createEventSource()` for real-time updates

## Technology Stack

### Frontend (kdes-fe)
- **Core**: React 18, Vite, JavaScript (ES modules)
- **UI**: Bootstrap 5, React Bootstrap, React Bootstrap Icons
- **Rich Text**: Lexical, Quill, Monaco Editor
- **File Upload**: Uppy (with direct upload endpoint integration)
- **Data Visualization**: Mermaid diagrams
- **Drag & Drop**: @dnd-kit
- **Real-time**: Socket.IO client
- **Routing**: React Router DOM v7
- **State**: React contexts and hooks

### Backend (kdes)
- **Core**: Python Flask, SQLAlchemy
- **Database**: PostgreSQL (via psycopg2-binary)
- **Real-time**: Flask-SocketIO
- **Authentication**: JWT tokens, OAuth support
- **AI Integration**: OpenAI API
- **Caching**: Redis support
- **SSL**: Configured for HTTPS (certificates in config)

## Development Environment

### Frontend Development
```bash
cd kdes-fe
npm install          # Install dependencies
npm run dev          # Start development server (Vite)
npm run build        # Production build
npm run lint         # ESLint checking
```

### Backend Development
```bash
cd kdes
# Activate virtual environment first
python run.py        # Start Flask development server (port 5002, HTTPS)
```

### Environment Configuration
- **Frontend**: Uses `VITE_API_BASE_URL=https://kairos:5002`
- **Backend**: Runs on `https://kairos:5002` with SSL certificates
- **Database**: PostgreSQL connection configured in `kdes/kairos/config.py`

## API Connection Details
- **Base URL**: `https://kairos:5002`
- **Authentication**: JWT Bearer tokens (managed by ApiBroker)
- **API Paths**: 
  - `/api/*` - General application APIs
  - `/api/auth/*` - Authentication endpoints
- **File Uploads**: Direct Uppy integration (exception to broker rule for technical reasons)
- **Downloads**: Via ApiBroker's `downloadFile()` method

## Coding Standards

### Code Comments
**ALWAYS richly comment code for legibility. Leave existing comments or update them as necessary.**

### Full-Stack Development Approach
When implementing new features:
1. **Plan both FE and BE changes together**
2. **Add BE API endpoints first** (in appropriate Flask blueprints)
3. **Add FE API calls** (in appropriate functional API modules using ApiBroker)
4. **Create/update UI components** to consume the new APIs
5. **Handle real-time updates** via Socket.IO if needed
6. **Test the complete flow** from UI to database

### File Organization
- **Frontend**: Organize by feature/domain (components, contexts, hooks)
- **Backend**: Use Flask blueprints for API organization
- **Shared Logic**: Keep API contracts consistent between FE and BE

## Real-time Communication
Both applications support Socket.IO for:
- Live updates to UI when data changes
- Real-time collaboration features
- System notifications and status updates

## Security Considerations
- **HTTPS**: All communication over SSL
- **JWT Authentication**: Tokens managed centrally via ApiBroker
- **File Security**: Downloads authenticated via UUID tokens
- **CORS**: Configured for cross-origin requests

## AI Assistant Integration
The backend includes OpenAI API integration for:
- Content generation and editing assistance
- Smart suggestions and automation
- Natural language processing features

## Working with this Project
This is configured as a **unified Warp project** where both frontend and backend can be developed simultaneously. When implementing new features:

1. **Understand the requirement** across both FE and BE
2. **Design the API contract** between them
3. **Implement backend endpoints** following Flask blueprint patterns
4. **Add frontend API calls** using the ApiBroker pattern
5. **Build UI components** that integrate cleanly
6. **Test the complete user journey**

The ApiBroker architecture ensures all API communication is maintainable, secure, and consistent across the entire application.
